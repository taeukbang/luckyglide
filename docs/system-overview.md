## LuckyGlide 시스템 개요 (아키텍처/동작 원리/목표)

### 제품 비전과 목표
- 초기 로딩을 매우 빠르게: 사전 수집한 최저가를 DB(Supabase)에 저장해 카드에서 즉시 표시
- 최신성 보장: 상세 그래프와 카드/상세의 “새로고침”으로 실시간에 준하는 최신 값 확인
- 신뢰성: “가격 수집 시점(collectedAt)”을 카드/상세에 명확히 표기해 투명성 확보

### 핵심 KPI(예시)
- 초기 카드 그리드 LCP ~1.0–1.5s (DB 캐시 기반)
- 새로고침 후 반영까지: 네트워크 왕복 + 스캔 시간 최소화(단일 목적지 14일 × 3~7일 체류)

## 데이터 흐름
- 스캔 저장(`server/scan.ts` 또는 서버리스 `api/scan.ts`)
  - MyRealTrip 캘린더 API를 호출하여 출발일(`dep`), 체류일(`len`) 조합별로 정확 복귀일 = `dep + (len-1)`의 가격을 수집
  - `fares` 테이블에 삽입하며, 새로 넣는 행들은 `is_latest=true`로 기록
  - 동일 경로(from,to)의 기존 `is_latest=true` 행은 일괄 `false` 처리

- 조회(목록) `/api/latest`
  - 뷰 `fares_city_extrema`를 사용해 `(from,to)`별로 `is_latest=true` 집합 중 최저가 1행을 반환
  - 추가로 해당 목적지의 최신 수집 시점(같은 `(from,to)`의 `is_latest=true` 중 최상단 `collected_at`)을 계산해 `collectedAt`으로 표기

- 조회(상세 그래프) `/api/calendar-window`
  - 특정 체류일(`tripDays`)로 지정된 기간(`days`) 동안, 출발일별 가격(정확 복귀일 매칭)을 계산하여 차트용 `{date: MM/DD, price}` 배열 반환

## 데이터 모델
- `fares`
  - 컬럼: `from`, `to`, `departure_date`, `return_date`, `trip_days`, `min_price`, `min_airline`, `collected_at`, `is_latest`
  - 인덱스: 경로/날짜, 수집시점, 최신 플래그
- `fares_city_extrema`(VIEW)
  - `is_latest=true` 집합 중 최저가 행을 1개 선택. 추가로 `(from,to)`별 최대가도 같이 제공(`max_price`)

## 서버(Express) 엔드포인트
- `GET /api/latest`
  - 쿼리: `from=ICN`, `region=아시아|...`, `codes=A,B,...`
  - 응답: 카드 표시용 `{ code, city, region, price, originalPrice, departureDate, returnDate, airline, tripDays, collectedAt }[]`
- `POST /api/scan`
  - 바디/쿼리: `from`, `to` (단일 목적지 스캔, 기본 14일)
  - 동작: `fares`에 최신 스냅샷 저장
- `POST /api/calendar-window`
  - 바디: `{ from, to, startDate?, days=30, tripDays }`
  - 응답: 차트용 `{ date: MM/DD, price }[]`

## 서버리스(Preview, Vercel Edge)
- `api/latest.ts`, `api/scan.ts`
  - Express와 동일한 인터페이스로 Preview 환경에서 동작
  - 환경변수: `SUPABASE_URL`, `SUPABASE_ANON_KEY` (Preview 스코프에 설정)

## 프론트 동작 (화면/UX)
- `src/pages/Index.tsx`
  - 초기 로딩: `/api/latest`로 DB 캐시값을 불러와 카드 그리드 렌더링
  - 카드 새로고침: `/api/scan` → `/api/latest?codes=...` 재조회 → 선택 카드만 상태 갱신
  - 동시 로딩: `refreshingCodes(Set)`로 각 카드별 로딩/완료 상태를 독립 관리
  - 반짝 효과: 완료 시 `justRefreshedCodes(Set)`을 통해 해당 카드 외곽선 파란 플래시 처리
  - 상세 다이얼로그: 열릴 때 `/api/latest?codes=...`로 상단 정보(collectedAt/여행일/가격) 동기화 후 `/api/calendar-window` 호출로 그래프 데이터 로딩
  - 상세 새로고침: 카드와 동일 로직 + 그래프 재호출

- `src/components/FlightCard.tsx`
  - `collectedAt` 표기, 새로고침 버튼(예약 버튼 왼쪽), 가격 변동 확인 버튼
  - 새로고침 완료 시 `lg-flash-outline` 외곽선 효과

- `src/components/FlightDetailDialog.tsx`
  - 상단 정보에 수집 시점 표기, 새로고침 버튼 추가, 국기 아이콘 카드와 동일 처리

- 스타일: `src/index.css`
  - `.lg-flash-outline` 키프레임으로 파란 외곽선 플래시

## 개발/실행 방법
- 로컬 개발
  - 서버: `npm run server:dev` (http://localhost:8787)
  - 프론트: `npm run dev` (http://localhost:8080, `/api` 프록시로 서버와 연동)
  - 환경변수: `SUPABASE_URL`, `SUPABASE_ANON_KEY`

- Vercel Preview
  - 브랜치 푸시 시 자동 배포, 서버리스 `api/` 라우트 사용
  - Preview 환경변수 설정 필수: `SUPABASE_URL`, `SUPABASE_ANON_KEY`

## 확장 아이디어(로드맵)
- 주기 스케줄러(크론)로 지정된 목적지 집합 자동 스캔
- 다중 출발지 지원 및 UI 필터 추가
- 가격 알림(웹훅/이메일)


---

## 환경변수와 구성

- 필수 환경변수
  - `SUPABASE_URL`: Supabase 프로젝트 URL
  - `SUPABASE_ANON_KEY`: Supabase anon 키
- 선택 환경변수
  - `MRT_CAL_BASE`: MyRealTrip 캘린더 API Base URL (기본값 `https://api3.myrealtrip.com`)

### 런타임/포트
- 프론트 개발 서버: Vite dev server `http://localhost:8080`
- 백엔드 개발 서버: Express `http://localhost:8787`
- 프록시: Vite가 `/api`를 8787로 프록시 (vite.config.ts 참고)

---

## 데이터베이스 스키마(DDL)와 뷰

다음 정의대로 Postgres(Supabase)에 스키마를 구성하면 동일 동작을 재현할 수 있습니다.

```sql
-- 테이블: 최신 스냅샷 단위를 is_latest=true로 표시
create table if not exists public.fares (
  id bigint generated by default as identity primary key,
  "from" text not null,
  "to" text not null,
  departure_date date not null,
  return_date date not null,
  trip_days int not null check (trip_days >= 1),
  min_price numeric,
  min_airline text,
  collected_at timestamptz not null default now(),
  is_latest boolean not null default false
);

-- 인덱스
create index if not exists idx_fares_route_dates on public.fares ("from", "to", departure_date, return_date);
create index if not exists idx_fares_collected_at on public.fares (collected_at desc);
create index if not exists idx_fares_latest_flag on public.fares ("from", "to", is_latest) where is_latest = true;

-- 최신 스냅샷 집합(is_latest=true) 중 최저가 1행을 반환하는 뷰
create or replace view public.fares_city_extrema as
with ranked as (
  select
    f."from",
    f."to",
    f.departure_date,
    f.return_date,
    f.trip_days,
    f.min_price,
    f.min_airline,
    f.collected_at,
    max(f.min_price) over (partition by f."from", f."to") as max_price,
    row_number() over (
      partition by f."from", f."to"
      order by f.min_price asc nulls last, f.departure_date asc, f.collected_at desc
    ) as rn
  from public.fares f
  where f.is_latest = true and f.min_price is not null
)
select
  "from",
  "to",
  departure_date,
  return_date,
  trip_days,
  min_price,
  max_price,
  min_airline,
  collected_at
from ranked
where rn = 1;
```

Notes
- `fares_city_extrema.collected_at`는 “최저가 행의 수집시점”입니다. UI 표기에는 동일 목적지의 최신 수집시점을 별도 쿼리로 계산해 사용합니다.

---

## API 스펙(OpenAPI 스타일)

Base URL
- 로컬 개발: `http://localhost:8787`
- Preview(서버리스): 호스트의 `/api` 경로

### GET /api/destinations
- 응답(200)
```json
{
  "regions": ["아시아", "유럽", ...],
  "destinations": [ { "nameKo": "도쿄", "code": "TYO", "region": "아시아" }, ... ]
}
```

### GET /api/latest
- 설명: DB 캐시 기반으로 `(from,to)`별 최저가 1행을 카드용으로 반환
- Query
  - `from` (string, default: `ICN`)
  - `region` (string, optional) — 필터
  - `codes` (string, optional) — `TYO,FUK,...`
- 응답(200)
```json
{
  "count": 3,
  "items": [
    {
      "code":"FUK","city":"후쿠오카","region":"아시아",
      "price": 123000, "originalPrice": 245000,
      "departureDate": "2025-10-18","returnDate": "2025-10-20",
      "airline": "XX","tripDays": 3,
      "collectedAt": "2025-10-16T09:10:00.000Z"
    }
  ]
}
```

### POST /api/scan
- 설명: 단일 목적지 스캔(기본 14일, 3~7일 체류) → `fares`에 최신 스냅샷 저장
- Query OR Body
  - `from` (string, default: `ICN`)
  - `to` (string, required)
- 응답(200)
```json
{ "ok": true, "rows": 210 }
```

### POST /api/scan-all (서버 전용)
- 설명: 다수 목적지 일괄 스캔
- Body: `{ from?: string, regions?: string[], codes?: string[] }`
- 응답(200): `{ routes: number, rows: number, regions: string[]|null, codes: string[]|null }`

### POST /api/calendar-window
- 설명: 특정 체류일수 `tripDays`로 `days`일 동안 출발일별 가격을 계산(정확 복귀일 매칭)
- Body
```json
{ "from":"ICN", "to":"FUK", "days":14, "tripDays":3 }
```
- 응답(200)
```json
{ "items": [ { "date": "10/18", "price": 123000 }, ... ] }
```

### GET /api/latest-live (서버 전용)
- 설명: DB를 우회하고 MyRealTrip 캘린더를 직접 스캔(인메모리 캐시 10분)

### GET /api/debug/fares (서버 전용)
- 설명: 최근 수집 행 확인
- Query: `from`, `to`, `limit`

서버리스(Preview)
- 동일 인터페이스 제공: `api/latest.ts`, `api/scan.ts` (Edge Runtime)

---

## 프론트엔드 계약(Contract)

카드 항목 타입
```ts
type LatestItem = {
  code: string;
  city: string;
  region: string | null;
  country: string | null;
  countryCode: string | null;
  price: number | null;
  originalPrice?: number | null;
  departureDate: string | null;
  returnDate: string | null;
  airline: string | null;
  collectedAt: string; // ISO
  tripDays?: number | null;
}
```

상세 그래프 데이터
```ts
type ChartPoint = { date: string /* MM/DD */, price: number }
```

UI 상태
- `refreshingCodes: Set<string>` — 카드별 새로고침 로딩 관리
- `justRefreshedCodes: Set<string>` — 카드별 반짝 하이라이트 (약 1초)

동작 규칙
- 카드 새로고침: `/api/scan` → `/api/latest?codes=...` → 해당 카드 상태만 갱신 → 다이얼로그 열려 있으면 그래프 재호출
- 다이얼로그 오픈: `/api/latest?codes=...`로 상단 값(collectedAt, tripDays, dates) 동기화 → `/api/calendar-window`로 그래프 적재

---

## 예약 링크(Deep Link) 규칙

함수 시그니처(요약)
```ts
buildMrtBookingUrl({
  from, fromNameKo, to, toNameKo, depdt, rtndt, adt=1, chd=0, inf=0, cabin="Y"
}): string
```

주요 파라미터 매핑
- `depctycd/arrctycd/depdt` 등 MyRealTrip 폼이 기대하는 중복 파라미터 구조를 유지
- `KSESID`는 고정값을 추가(테스트 목적). 실제 운영에선 적절한 세션 파라미터 사용 권장

---

## 빌드/실행/배포 절차

로컬
1) 환경변수 설정(`SUPABASE_URL`, `SUPABASE_ANON_KEY`)
2) 백엔드: `npm run server:dev`
3) 프론트: `npm run dev` (프록시로 연결)

Vercel Preview
- 브랜치 푸시 → 자동 빌드/배포
- Preview 환경변수 설정 필수: `SUPABASE_URL`, `SUPABASE_ANON_KEY`

---

## 오류 처리/성능/관찰성

- 오류 처리: fetch 타임아웃(예: 12s)과 재시도 최소화, 실패 시 UX 연성복구(스피너/무음 실패)
- 성능: 초기 `/api/latest` 1회 호출로 카드 전체 렌더; 스캔 범위는 14일 × 3~7일로 제한
- 관찰성: `/api/debug/fares`로 최근 수집행 점검, Vercel/서버 로그로 트러블슈팅

---

## 수동 테스트 체크리스트

- 초기 진입 시 카드가 1~2초 내 렌더되는지
- 카드 “새로고침” 후 해당 카드만 가격/수집시점이 갱신되고 파란 외곽선이 1초간 표시되는지
- 상세 다이얼로그 오픈 시 상단 정보가 최신으로 동기화되는지, 기간 변경 시 그래프가 갱신되는지


